#!/usr/bin/env python

"""
Usage: yturl [options] <url>

Options:
  -h, --help             This help text.
  -q, --quality QUALITY  Either an itag or low/medium/high. [default: medium]
"""

from __future__ import print_function
from docopt import docopt
import sys

try:
    from urllib.request import urlopen
    from urllib.parse import parse_qs, urlparse
except ImportError:  # Python 2 fallback
    from urllib import urlopen
    from urlparse import parse_qs, urlparse


def default_itag_order():
    """
    Return itags in order of quality preference.

    :returns: itags sorted in default order
    """

    itags = {
    #   itag    v-dimensions v-bitrate a-bitrate a-samplerate v-encoding
        "5":   (400*240,     0.25,     64,       22.05,       "h263"),
        "6":   (480*270,     0.8,      64,       22.05,       "h263"),
        "13":  (176*144,     0.5,      64,       22.05,       "mp4v"),
        "17":  (176*144,     2,        64,       22.05,       "mp4v"),
        "18":  (640*360,     0.5,      96,       44.1,        "h264"),
        "22":  (1280*720,    2.9,      192,      44.1,        "h264"),
        "34":  (640*360,     0.5,      128,      44.1,        "h264"),
        "35":  (854*480,     1,        128,      44.1,        "h264"),
        "36":  (320*240,     0.17,     38,       44.1,        "mp4v"),
        "37":  (1920*1080,   2.9,      192,      44.1,        "h264"),
        "38":  (4096*3072,   5,        192,      44.1,        "h264"),
        "43":  (640*360,     0.5,      128,      44.1,        "vp8"),
        "44":  (854*480,     1,        128,      44.1,        "vp8"),
        "45":  (1280*720,    2,        192,      44.1,        "vp8"),
        "46":  (1920*1080,   2,        192,      44.1,        "vp8"),
    }

    return sorted(
        itags,
        reverse=True,
        key=lambda x: itags[x]
    )


def strip_to_video_id(url):
    """
    Strip a URL to its video ID.

    :param url: a url containing a video ID
    :returns: the video ID
    """

    url_params = parse_qs(urlparse(url).query)

    if "v" in url_params:
        return url_params["v"][0]
    else:
        maximum_video_id_length = 11
        return url.split("/")[-1][:maximum_video_id_length]


def itag_order(desired_itag, known_itags):
    """
    Return the desired itag sorting.

    :param desired_itag: the itag to sort based upon
    :param known_itags: locally known itags (sorted)
    :returns: the preferential order of itags
    """

    return list(zip(*sorted(
        enumerate(known_itags),
        key=lambda x: abs(known_itags.index(desired_itag) - x[0]))
    ))[1]


def available_itags(video_id, test_file_handle=None):
    """
    Return available itags and their associated URLs as a list.

    :param video_id: the video ID to get itags for
    :param test_file_handle: read from file handle (for testing)
    """

    if test_file_handle is None:
        url = "http://youtube.com/get_video_info?hl=en&video_id=" + video_id
        res_handle = urlopen(url)
    else:
        res_handle = test_file_handle

    res_data = parse_qs(res_handle.read().decode("utf8"))

    if "url_encoded_fmt_stream_map" in res_data:
        streams_raw = res_data["url_encoded_fmt_stream_map"][0]
        streams = streams_raw.split(",")

        for stream in streams:
            stream = parse_qs(stream)
            video = dict((k, v[0]) for k, v in stream.items())
            yield video["itag"], "%(url)s&signature=%(sig)s" % video
    else:
        raise LookupError(res_data["reason"][0])


def quality_group(group, itags_in_quality_order):
    """
    Parse string based quality groups into their itag equivalents.

    :param name: the name of the quality group to be parsed
    :param itags_in_quality_order: a list of locally known itags, in order
    :returns: the associated itag, or None if the group is unknown
    """

    groups = {
        "low": -1,
        "medium": len(itags_in_quality_order) // 2,
        "high": 0,
    }

    if group in groups:
        return itags_in_quality_order[groups[group]]
    elif group in itags_in_quality_order:
        return group


if __name__ == "__main__":
    args = docopt(__doc__)

    video_id = strip_to_video_id(args["<url>"])
    known_itags = default_itag_order()

    desired_itag = quality_group(args["--quality"], known_itags)
    if desired_itag is None:
        print("Unknown quality: " + args["--quality"], file=sys.stderr)
        sys.exit(2)

    try:
        avail_itags = dict(available_itags(video_id))
    except LookupError as e:
        print("The YouTube API returned an error: " + str(e), file=sys.stderr)
        sys.exit(3)

    ordered_itags = itag_order(desired_itag, known_itags)
    suitable_itags = [x for x in ordered_itags if x in avail_itags]

    if suitable_itags:
        used_itag = suitable_itags[0]
        used_url = avail_itags[used_itag]
        print("Using itag %s." % used_itag, file=sys.stderr)
        print(used_url)
    else:
        print("No local itags available.", file=sys.stderr)
        sys.exit(1)
