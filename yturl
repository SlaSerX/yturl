#!/usr/bin/env python

from __future__ import print_function
import argparse
import sys

try:
    from urllib.request import urlopen
    from urllib.parse import parse_qs, urlparse
    from itertools import zip_longest
except ImportError:  # Python 2 fallback
    from urllib import urlopen
    from urlparse import parse_qs, urlparse
    from itertools import izip_longest as zip_longest


def default_itag_order():
    """
    Return itags in order of quality preference.

    :returns: itags sorted in default order
    """

    itags = {
    #   itag    v-dimensions v-bitrate a-bitrate a-samplerate v-encoding
        "5":   (400*240,     0.25,     64,       22.05,       "h263"),
        "6":   (480*270,     0.8,      64,       22.05,       "h263"),
        "13":  (176*144,     0.5,      64,       22.05,       "mp4v"),
        "17":  (176*144,     2,        64,       22.05,       "mp4v"),
        "18":  (640*360,     0.5,      96,       44.1,        "h264"),
        "22":  (1280*720,    2.9,      192,      44.1,        "h264"),
        "34":  (640*360,     0.5,      128,      44.1,        "h264"),
        "35":  (854*480,     1,        128,      44.1,        "h264"),
        "36":  (320*240,     0.17,     38,       44.1,        "mp4v"),
        "37":  (1920*1080,   2.9,      192,      44.1,        "h264"),
        "38":  (4096*3072,   5,        192,      44.1,        "h264"),
        "43":  (640*360,     0.5,      128,      44.1,        "vp8"),
        "44":  (854*480,     1,        128,      44.1,        "vp8"),
        "45":  (1280*720,    2,        192,      44.1,        "vp8"),
        "46":  (1920*1080,   2,        192,      44.1,        "vp8"),
    }
    return sorted(itags, reverse=True, key=lambda x: itags[x])


def strip_to_video_id(url):
    """
    Strip a URL to its video ID.

    :param url: a url containing a video ID
    :returns: the video ID
    """

    url_params = parse_qs(urlparse(url).query)

    try:
        return url_params["v"][0]
    except KeyError:
        maximum_video_id_length = 11
        return url.split("/")[-1][:maximum_video_id_length]


def itag_order(desired_itag, known_itags):
    """
    Return the desired itag sorting.

    :param desired_itag: the itag to sort based upon
    :param known_itags: locally known itags (sorted)
    :returns: the preferential order of itags
    """

    pivot = known_itags.index(desired_itag)
    for pair in zip_longest(known_itags[pivot::-1], known_itags[pivot+1:]):
        for itag in pair:
            if itag is not None:
                yield itag


def available_itags(video_id):
    """
    Return available itags and their associated URLs as a list.

    :param video_id: the video ID to get itags for
    """

    url = "http://youtube.com/get_video_info?hl=en&video_id=" + video_id
    res_handle = urlopen(url)
    res_data = parse_qs(res_handle.read().decode("utf8"))

    try:
        streams_raw = res_data["url_encoded_fmt_stream_map"][0]
    except KeyError:
        raise LookupError(res_data["reason"][0])
    else:
        streams = streams_raw.split(",")
        for stream in streams:
            stream = parse_qs(stream)
            video = dict((k, v[0]) for k, v in stream.items())
            yield video["itag"], video["url"]


def quality_group(group, itags_in_quality_order):
    """
    Parse string based quality groups into their itag equivalents.

    :param name: the name of the quality group to be parsed
    :param itags_in_quality_order: a list of locally known itags, in order
    :returns: the associated itag, or None if the group is unknown
    """

    groups = {
        "low": -1,
        "medium": len(itags_in_quality_order) // 2,
        "high": 0,
    }

    try:
        return itags_in_quality_order[groups[group]]
    except KeyError:
        if group in itags_in_quality_order:
            return group


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "-q", "--quality",
        help='"low", "medium", "high", or an itag',
        default="medium",
    )
    parser.add_argument(
        "url",
        metavar="video_id/url",
        help="a YouTube url (or bare video ID)",
    )
    args = parser.parse_args()

    video_id = strip_to_video_id(args.url)
    known_itags = default_itag_order()

    desired_itag = quality_group(args.quality, known_itags)
    if desired_itag is None:
        print("Unknown quality: " + args.quality, file=sys.stderr)
        sys.exit(2)

    try:
        avail_itags = dict(available_itags(video_id))
    except LookupError as err:
        print("YouTube API error: " + str(err), file=sys.stderr)
        sys.exit(3)

    ordered_itags = itag_order(desired_itag, known_itags)
    suitable_itags = [x for x in ordered_itags if x in avail_itags]

    if suitable_itags:
        used_itag = suitable_itags[0]
        used_url = avail_itags[used_itag]
        print("Using itag %s." % used_itag, file=sys.stderr)
        print(used_url)
    else:
        print("No local itags available.", file=sys.stderr)
        sys.exit(1)
