#!/usr/bin/env python

import os
import sys
import urllib
import urlparse
import json

class ItagLoadError(Exception):
    """Raised when we can't get our local itag database."""
    pass

class YouTubeAPIError(Exception):
    """Raised when the YouTube API returns something that we don't understand."""
    pass

class YTURL():
    """Functions to get direct URLs to YouTube media."""
    def getItagQualityOrder(self, itags):
        return sorted(itags, reverse=True, key=lambda x: (
            itags[x]["video"]["dimensions"]["width"] * itags[x]["video"]["dimensions"]["height"],
            itags[x]["video"]["bitrate"],
            itags[x]["audio"]["bitrate"],
            itags[x]["audio"]["samplerate"]
        ))

    def stripToYouTubeVideoID(self, url):
        """Strip URL to the video ID contained."""
        try:
            parsedURL = urlparse.urlparse(url).query
            return urlparse.parse_qs(parsedURL)["v"][0][:11]
        except (ValueError, KeyError):
            return url.split("/")[-1][:11]

    def getAvailableVideoItags(self, videoID):
        """Return available itags and their associated URLs as a list."""
        apiResponse = urllib.urlopen("http://youtube.com/get_video_info?video_id=" + videoID)
        parsedResponse = urlparse.parse_qs(apiResponse.read())
        try:
            for mediaFormat in parsedResponse["url_encoded_fmt_stream_map"][0].split(","):
                parsedFormat = urlparse.parse_qs(mediaFormat)
                yield (
                    parsedFormat["itag"][0],
                    "%s&signature=%s" % (parsedFormat["url"][0], parsedFormat["sig"][0])
                )
        except (KeyError, IndexError):
            raise YouTubeAPIError("API returned failure: %s" % apiData["reason"][0])

    def getDesiredItagOrder(self, userItags, qualityOrder):
        """Return the desired itag sorting."""
        if len(userItags) == 1:
            return zip(*sorted(
                enumerate(qualityOrder),
                key=lambda (i, x): abs(qualityOrder.index(userItags[0]) - i))
            )[1]
        return userItags + qualityOrder

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print "Usage: %s video-id [itag1 ... itagN]" % os.path.basename(sys.argv[0])
        sys.exit(1)

    localItagFile = os.path.expanduser("~/.config/yturl/itags")
    try:
        with open(localItagFile) as f:
            knownItags = json.load(f)
    except (IOError, OSError), e:
        raise ItagLoadError("Can't load itags file %s: %s" %
            (localItagFile, e.args[1])
        ) 
        
    
    y = YTURL()
    
    userItags = sys.argv[2:]
    videoID = y.stripToYouTubeVideoID(sys.argv[1])
    qualityOrder = y.getItagQualityOrder(knownItags)
    availableItags = dict(y.getAvailableVideoItags(videoID))
    
    if not set(userItags).issubset(qualityOrder):
        raise ValueError("Invalid itag(s):" + ", ".join(set(userItags).difference(qualityOrder)))
    for itag in y.getDesiredItagOrder(userItags, qualityOrder):
        if itag in availableItags:
            print availableItags[itag]
            print >> sys.stderr, "Using itag %s." % itag 
            break
    else:
        print >> sys.stderr, "No locally known itags available."
