#!/usr/bin/env python
# vim: set fileencoding=utf-8 :

"""Prints direct URLs to YouTube media."""

# (c) Christopher Down 2011-2012
# See the COPYING file for copyright information.

from urllib import urlopen, urlencode
from urlparse import parse_qs
import sys

__version__ = 1.03

class YouTubeAPIError(Exception):
    """Raised when the YouTube API returns something that we don't understand."""
    pass

class YTURL():
    """Functions to get direct URLs to YouTube media."""
    def getItagQualityOrder(self):
        """Return itags in order of quality preference."""
        itags = {
        #   itag   v-dimensions v-bitrate a-bitrate a-samplerate
            "5":  (400*240,     0.25,     64,       22.05),
            "6":  (480*270,     0.8,      64,       22.05),
            "13": (176*144,     0.5,      64,       22.05),
            "17": (176*144,     2,        64,       22.05),
            "18": (640*360,     0.5,      128,      44.1),
            "22": (1280*720,    2.9,      96,       44.1),
            "34": (640*360,     0.5,      128,      44.1),
            "35": (854*480,     1,        128,      44.1),
            "37": (1920*1080,   2.9,      152,      44.1),
            "38": (4096*3072,   5,        152,      44.1),
            "43": (640*360,     0.5,      128,      44.1),
            "44": (854*480,     1,        128,      44.1),
            "45": (1280*720,    2,        192,      44.1),
        }
        return sorted(itags, reverse=True, key=lambda x: itags[x])

    def stripToYouTubeVideoID(self, url):
        """Strip URL to the video ID contained."""
        try:
            return parse_qs(url[url.index("?")+1:])["v"][0][:11]
        except ValueError, KeyError:
            return url.split("/")[-1][:11]

    def getAvailableVideoItags(self, videoID):
        """Return available itags and their associated URLs as a list."""
        apiData = parse_qs(urlopen("http://youtube.com/get_video_info?" +
                                   urlencode({"video_id":videoID, "el":"detailpage"})).read())
        try:
            for videoFormat in map(parse_qs, apiData["url_encoded_fmt_stream_map"][0].split(",")):
                yield videoFormat["itag"][0], videoFormat["url"][0]
        except KeyError, e:
            if apiData["status"][0] == "fail" and "reason" in apiData:
                raise YouTubeAPIError("API returned failure: %s" % apiData["reason"][0])
            raise YouTubeAPIError("API output missing required key: %s (bad ID?)" % e)

    def getDesiredItagOrder(self, desired, quality):
        """Return the desired itag sorting."""
        if len(desired) == 1:
            return zip(*sorted(enumerate(quality), key=lambda (i,x):abs(quality.index(desired[0])-i)))[1]
        return desired + quality

def main():
    """Run main program."""
    if len(sys.argv) < 2:
        raise SyntaxError("Usage: yturl id [itag ...]")
    y = YTURL()
    videoItagQualityOrder = y.getItagQualityOrder()
    for itag in sys.argv[2:]:
        if itag not in videoItagQualityOrder:
            raise ValueError("%s is not a valid itag." % itag)
    videoID = y.stripToYouTubeVideoID(sys.argv[1])
    availableFormats = dict(y.getAvailableVideoItags(videoID))
    for itag in y.getDesiredItagOrder(sys.argv[2:], videoItagQualityOrder):
        if itag in availableFormats:
            print >> sys.stderr, "Using itag %s." % itag
            print availableFormats[itag]
            return True
    raise YouTubeAPIError("No local itags available")

if __name__ == "__main__":
    main()
